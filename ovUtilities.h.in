/*=========================================================================

  Program:  ovis (OrlandoVision)
  Module:   ovUtilities.h
  Language: C++

  Author: Patrick Emond <emondpd@mcmaster.ca>

=========================================================================*/
//
// .SECTION Description
// A utilities header to include typedefs, macros, global functions, etc.
//

#ifndef __vtkUtilities_h
#define __vtkUtilities_h

#define OVIS_VERSION_MAJOR @OVIS_VERSION_MAJOR@
#define OVIS_VERSION_MINOR @OVIS_VERSION_MINOR@
#define OVIS_VERSION_PATCH @OVIS_VERSION_PATCH@
#define OVIS_RESOURCES_DIR "@OVIS_RESOURCES_DIR@"

// for atoi
#include <stdio.h>
#include <stdlib.h>

// STL headers and typedefs
#include <vtkstd/map>
#include <vtkstd/stack>
#include <vtkstd/string>
#include <vtkstd/vector>

typedef vtkstd::string ovString;
typedef vtkstd::vector< ovString > ovStringVector;

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
inline int ovGetMaxDays( int year, int month )
{
  if( 1 == month || 3 == month || 5 == month || 7 == month ||
      8 == month || 10 == month || 12 == month )
  {
    return 31;
  }

  if( 4 == month || 6 == month || 9 == month || 11 == month )
  {
    return 30;
  }
  
  // The only month left is February, the "our calendar doesn't actually work
  // so let's use this month to try and fix it" month.  We need to determine
  // whether or not the given year is a leap year.  The algorithm to determine
  // whether this is a leap year taken from wikipedia:
  // http://en.wikipedia.org/wiki/Leap_year
  bool leapYear = 0 == year % 400 ? true
                : 0 == year % 100 ? false
                : 0 == year % 4 ? true
                : false;

  return leapYear ? 29 : 28;
}

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovDate
{
  unsigned short year;
  unsigned short month;
  unsigned short day;
  ovDate() : year( 0 ), month( 0 ), day( 0 ) {}
  ovDate( unsigned short y, unsigned short m, unsigned short d ) : year( y ), month( m ), day( d )
  { this->Validate(); }

  ovDate( int date )
  {
    this->day = date % 100;
    this->month = ( ( date - this->day ) % 10000 ) / 100;
    this->year = ( date - this->month - this->day ) / 10000;
    this->Validate();
  }

  ovDate( const char *date )
  {
    this->year = 0;
    this->month = 0;
    this->day = 0;
    
    ovString dateStr = ovString( date );

    size_t first = dateStr.find( '-' );
    if( vtkstd::string::npos != first )
    {
      this->year = atoi( dateStr.substr( 0, first ).c_str() );

      size_t second = dateStr.find( '-', first + 1 );
      if( vtkstd::string::npos != second )
      {
        this->month = atoi( dateStr.substr( first + 1, second - first - 1 ).c_str() );
        this->day = atoi( dateStr.substr( second + 1, dateStr.length() - second - 1 ).c_str() );
      }
    }
    this->Validate();
  }

  int ToInt() { return 10000 * this->year + 100 * month + day; }

  void ToString( ovString &dateString )
  {
    char buffer[64];
    sprintf( buffer, this->year ? "%d-%02d-%02d" : "", this->year, this->month, this->day );
    dateString = buffer;
  }

  void Validate()
  {
    // range checking
    if( 0 > this->year ) this->year = 0;
    if( 0 > this->month || 12 < this->month ) this->month = 0;

    // not necessary to bother with exact number of days per month
    if( 0 > this->day || ovGetMaxDays( this->year, this->month ) < this->day ) this->day = 0;
  }

  bool operator == ( ovDate rhs )
  {
    return this->year == rhs.year &&
           this->month == rhs.month &&
           this->day == rhs.day;
  }

  bool operator < ( ovDate rhs )
  {
    return this->year < rhs.year ||
           ( this->year == rhs.year &&
             this->month < rhs.month ) ||
           ( this->year == rhs.year &&
             this->month == rhs.month &&
             this->day < rhs.day );
  }

  bool operator <= ( ovDate rhs ) { return *this == rhs || *this < rhs; }
  bool operator > ( ovDate rhs ) { return rhs < *this; }
  bool operator >= ( ovDate rhs ) { return rhs <= *this; }
  bool operator != ( ovDate rhs ) { return !( *this == rhs ); }
};

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovDatePeriod
{
  ovString name;
  ovDate start;
  ovDate end;
  ovDatePeriod( ovString n, ovDate s, ovDate e ) : name( n ), start( s ), end( e ) {}
};
typedef vtkstd::vector< ovDatePeriod* > ovDatePeriodVector;

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovTag
{
  ovString parent;
  ovString name;
  bool active;
  ovTag( ovString p, ovString n, int a = 1 ) : parent( p ), name( n ), active( a ) {}
  ovTag( ovString n, int a = 1 ) : parent( "" ), name( n ), active( a ) {}
};

typedef vtkstd::vector< ovTag* > ovTagVector;
typedef vtkstd::pair< ovTagVector::iterator, ovTagVector::iterator > ovTagVectorRange;

inline bool ovTagCompare( ovTag *a, ovTag *b )
{ return a->name == b->name; }
inline bool ovTagSort( ovTag *a, ovTag *b )
{ return a->name < b->name; }

inline long ovHash( ovString str )
{
  vtkstd::locale ovLocale( "POSIX" );
  const vtkstd::collate< char > &ovCollate = vtkstd::use_facet< vtkstd::collate< char > >( ovLocale );
  return ovCollate.hash( str.data(), str.data() + str.length() );
}

#endif // __vtkUtilities_h
