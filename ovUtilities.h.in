/*=========================================================================

  Program:  ovis (OrlandoVision)
  Module:   ovUtilities.h
  Language: C++

  Author: Patrick Emond <emondpd@mcmaster.ca>

=========================================================================*/
//
// .SECTION Description
// A utilities header to include typedefs, macros, global functions, etc.
//

#ifndef __vtkUtilities_h
#define __vtkUtilities_h

#define OVIS_VERSION_MAJOR @OVIS_VERSION_MAJOR@
#define OVIS_VERSION_MINOR @OVIS_VERSION_MINOR@
#define OVIS_VERSION_PATCH @OVIS_VERSION_PATCH@
#define OVIS_RESOURCES_DIR "@OVIS_RESOURCES_DIR@"

// for atoi
#include <stdio.h>
#include <stdlib.h>

// STL headers and typedefs
#include <vtkstd/map>
#include <vtkstd/stack>
#include <vtkstd/string>
#include <vtkstd/vector>

typedef vtkstd::string ovString;
typedef vtkstd::vector< ovString > ovStringVector;

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct safe_delete
{
  template <typename T>
  void operator()( T *&p ) { if( p ) { delete p; p = 0; } };
};

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
inline bool ovIsOppositeColorWhite( double r, double g, double b, double a = 1.0 ) { return r + g + b <= 0.66; }
inline bool ovIsOppositeColorWhite( double *rgba ) { return ovIsOppositeColorWhite( rgba[0], rgba[1], rgba[2] ); }

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovDate
{
  int year;
  int month;
  int day;
  ovDate() : year( 0 ), month( 0 ), day( 0 ) {}
  ovDate( int y, int m, int d ) : year( y ), month( m ), day( d ) { this->Validate(); }
  ovDate( int date ) { this->SetDate( date ); }
  ovDate( const char *date ) { this->SetDate( date ); }

  static int DaysInMonth( int year, int month )
  {
    if( 1 == month || 3 == month || 5 == month || 7 == month ||
        8 == month || 10 == month || 12 == month ) return 31;
    if( 4 == month || 6 == month || 9 == month || 11 == month ) return 30;
    
    // The only month left is February, the "our calendar doesn't actually work
    // so let's use this month to try and fix it" month.  We need to determine
    // whether or not the given year is a leap year.  The algorithm to determine
    // whether this is a leap year taken from wikipedia:
    // http://en.wikipedia.org/wiki/Leap_year
    bool leapYear = 0 == year % 400 ? true
                  : 0 == year % 100 ? false
                  : 0 == year % 4 ? true
                  : false;
  
    return leapYear ? 29 : 28;
  }

  void SetDate( const char *date )
  {
    this->year = 0;
    this->month = 0;
    this->day = 0;
    
    ovString dateStr = ovString( date );

    size_t first = dateStr.find( '-' );
    if( vtkstd::string::npos != first )
    {
      this->year = atoi( dateStr.substr( 0, first ).c_str() );

      size_t second = dateStr.find( '-', first + 1 );
      if( vtkstd::string::npos != second )
      {
        this->month = atoi( dateStr.substr( first + 1, second - first - 1 ).c_str() );
        this->day = atoi( dateStr.substr( second + 1, dateStr.length() - second - 1 ).c_str() );
      }
    }
    this->Validate();
  }

  void SetDate( int date )
  {
    this->day = date % 100;
    this->month = ( ( date - this->day ) % 10000 ) / 100;
    this->year = ( date - this->month - this->day ) / 10000;
    this->Validate();
  }
  
  bool IsSet() { return 0 < this->year; } const
  int ToInt() { return 10000 * this->year + 100 * month + day; } const
  void ToString( ovString &dateString ) const
  {
    char buffer[64];
    sprintf( buffer, this->year ? "%d-%02d-%02d" : "", this->year, this->month, this->day );
    dateString = buffer;
  }

  void Validate()
  {
    // range checking
    if( 0 > this->year ) this->year = 0;
    if( 0 > this->month || 12 < this->month ) this->month = 0;

    // not necessary to bother with exact number of days per month
    if( 0 > this->day || ovDate::DaysInMonth( this->year, this->month ) < this->day ) this->day = 0;
  }

  bool operator == ( const ovDate &rhs ) const
  {
    return this->year == rhs.year &&
           this->month == rhs.month &&
           this->day == rhs.day;
  }

  bool operator < ( const ovDate &rhs ) const
  {
    return this->year < rhs.year ||
           ( this->year == rhs.year &&
             this->month < rhs.month ) ||
           ( this->year == rhs.year &&
             this->month == rhs.month &&
             this->day < rhs.day );
  }

  bool operator <= ( const ovDate &rhs ) const { return *this == rhs || *this < rhs; }
  bool operator > ( const ovDate &rhs ) const { return rhs < *this; }
  bool operator >= ( const ovDate &rhs ) const { return rhs <= *this; }
  bool operator != ( const ovDate &rhs ) const { return !( *this == rhs ); }
};

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovDatePeriod
{
  ovString name;
  ovDate start;
  ovDate end;
  ovDatePeriod( ovString n, ovDate s, ovDate e ) : name( n ), start( s ), end( e ) {}
};
typedef vtkstd::vector< ovDatePeriod* > ovDatePeriodVector;

//-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-+#+-
struct ovTag
{
  ovString parent;
  ovString name;
  bool active;
  bool expanded;
  double color[4];
  ovTag() : parent( "" ), name( "" ), active( false ) { this->expanded = false; }
  ovTag( ovString n, int a = 1 ) : parent( "" ), name( n ), active( a ) { this->expanded = false; }
  ovTag( ovString p, ovString n, int a = 1 ) : parent( p ), name( n ), active( a ) { this->expanded = false; }
  void DeepCopy( const ovTag* tag )
  {
    this->parent = tag->parent;
    this->name = tag->name;
    this->active = tag->active;
    this->expanded = tag->expanded;
    for( int i = 0; i < 4; i++ ) this->color[i] = tag->color[i];
  }
  bool operator == ( const ovTag &rhs ) const
  {
    return this->parent == rhs.parent &&
           this->name == rhs.parent &&
           this->active == rhs.active &&
           this->expanded == rhs.expanded &&
           this->color[0] == rhs.color[0] &&
           this->color[1] == rhs.color[1] &&
           this->color[2] == rhs.color[2] &&
           this->color[3] == rhs.color[3];
  }
  bool operator != ( const ovTag &rhs ) const { return !( (*this) == rhs ); }
};

typedef vtkstd::vector< ovTag* > ovTagVector;

#endif // __vtkUtilities_h
